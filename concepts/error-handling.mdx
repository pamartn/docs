---
title: "Error Handling"
description: "Learn how to handle API errors gracefully"
---

## Error Response Format

All Fetchin API errors return a JSON object with an `error` field:

```json
{
  "error": "Error message describing what went wrong"
}
```

## HTTP Status Codes

### 400 Bad Request

Invalid parameters or malformed request.

**Example:**
```json
{
  "error": "Missing profileUrlOrUrn parameter"
}
```

**Common causes:**
- Missing required parameters
- Invalid parameter format
- Malformed LinkedIn URL

**Solution:**
- Check that all required parameters are included
- Verify parameter values are properly formatted
- Use LinkedIn profile URLs in the correct format

### 401 Unauthorized

Invalid or missing API key.

**Example:**
```json
{
  "error": "Invalid API key"
}
```

**Common causes:**
- Missing `X-API-Key` header
- Incorrect API key value
- Revoked or expired API key

**Solution:**
- Include the `X-API-Key` header in your request
- Copy your API key from the dashboard
- Verify you're using the correct key

### 429 Too Many Requests

Quota exceeded for your current plan.

**Example:**
```json
{
  "error": "Quota exceeded. Upgrade your plan or wait for renewal."
}
```

**Common causes:**
- Monthly quota depleted
- Too many requests in short time period

**Solution:**
- Wait for quota renewal (check dashboard for date)
- Upgrade to a plan with higher limits
- Implement request caching to reduce usage

### 500 Internal Server Error

Server-side error occurred.

**Example:**
```json
{
  "error": "Failed to fetch LinkedIn data"
}
```

**Common causes:**
- Temporary server issue
- LinkedIn API unavailable
- Network timeout

**Solution:**
- Retry the request with exponential backoff
- Check API status page
- Contact support if error persists

## Error Handling Examples

### JavaScript/TypeScript

<CodeGroup>

```javascript Async/Await
async function fetchLinkedInPosts(profileUrl, apiKey) {
  try {
    const response = await fetch(
      `https://your-domain.com/api/v1/posts?profileUrlOrUrn=${encodeURIComponent(profileUrl)}`,
      {
        headers: { 'X-API-Key': apiKey }
      }
    );
    
    if (!response.ok) {
      const error = await response.json();
      
      switch (response.status) {
        case 400:
          console.error('Invalid request:', error.error);
          break;
        case 401:
          console.error('Authentication failed:', error.error);
          break;
        case 429:
          console.error('Quota exceeded:', error.error);
          break;
        case 500:
          console.error('Server error:', error.error);
          break;
        default:
          console.error('Unknown error:', error.error);
      }
      
      throw new Error(error.error);
    }
    
    return await response.json();
  } catch (err) {
    console.error('Request failed:', err);
    throw err;
  }
}
```

```javascript With Retry Logic
async function fetchWithRetry(url, options, maxRetries = 3) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      
      if (response.status === 429) {
        const waitTime = Math.pow(2, attempt) * 1000;
        console.log(`Rate limited. Waiting ${waitTime}ms...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        continue;
      }
      
      if (response.status === 500) {
        if (attempt < maxRetries - 1) {
          const waitTime = 1000 * (attempt + 1);
          await new Promise(resolve => setTimeout(resolve, waitTime));
          continue;
        }
      }
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error);
      }
      
      return await response.json();
    } catch (err) {
      if (attempt === maxRetries - 1) throw err;
    }
  }
}
```

</CodeGroup>

### Python

<CodeGroup>

```python Basic Error Handling
import requests

def fetch_linkedin_posts(profile_url, api_key):
    try:
        response = requests.get(
            'https://your-domain.com/api/v1/posts',
            headers={'X-API-Key': api_key},
            params={'profileUrlOrUrn': profile_url}
        )
        
        if response.status_code == 400:
            error = response.json()
            print(f"Invalid request: {error['error']}")
        elif response.status_code == 401:
            error = response.json()
            print(f"Authentication failed: {error['error']}")
        elif response.status_code == 429:
            error = response.json()
            print(f"Quota exceeded: {error['error']}")
        elif response.status_code == 500:
            error = response.json()
            print(f"Server error: {error['error']}")
        
        response.raise_for_status()
        return response.json()
        
    except requests.exceptions.RequestException as err:
        print(f"Request failed: {err}")
        raise
```

```python With Retry Logic
import time
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def fetch_with_retry(url, headers, params, max_retries=3):
    session = requests.Session()
    
    retry = Retry(
        total=max_retries,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504]
    )
    
    adapter = HTTPAdapter(max_retries=retry)
    session.mount('http://', adapter)
    session.mount('https://', adapter)
    
    try:
        response = session.get(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as err:
        print(f"Request failed after {max_retries} retries: {err}")
        raise
```

</CodeGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Always check HTTP status codes">
    Don't assume requests succeed. Check `response.ok` or `response.status_code` before processing data.
  </Accordion>

  <Accordion title="Implement exponential backoff">
    For 429 and 500 errors, wait progressively longer between retries: 1s, 2s, 4s, 8s, etc.
  </Accordion>

  <Accordion title="Log errors with context">
    Include request parameters, timestamps, and user context in error logs for debugging.
  </Accordion>

  <Accordion title="Display user-friendly messages">
    Translate technical errors into actionable messages for end users.
  </Accordion>

  <Accordion title="Set request timeouts">
    Don't wait forever. Set reasonable timeouts (e.g., 30 seconds) for API requests.
  </Accordion>

  <Accordion title="Monitor error rates">
    Track error rates in your application to catch issues early.
  </Accordion>
</AccordionGroup>

## Debugging Tips

### Enable Verbose Logging

<CodeGroup>

```bash cURL
curl -v -X GET "https://your-domain.com/api/v1/posts?profileUrlOrUrn=..." \
  -H "X-API-Key: your-api-key"
```

```javascript JavaScript
console.log('Making request to:', url);
console.log('Headers:', headers);

const response = await fetch(url, { headers });

console.log('Response status:', response.status);
console.log('Response headers:', response.headers);
```

</CodeGroup>

### Check API Status

If you're experiencing persistent errors:

1. Check your dashboard for quota status
2. Verify your API key is active
3. Test with a known-good LinkedIn profile URL
4. Contact support with error details

## Error Prevention

<CardGroup cols={2}>
  <Card title="Validate inputs" icon="check">
    Validate LinkedIn URLs before making API requests
  </Card>
  <Card title="Cache responses" icon="database">
    Store successful responses to avoid redundant requests
  </Card>
  <Card title="Monitor quota" icon="gauge">
    Check remaining quota before bulk operations
  </Card>
  <Card title="Test thoroughly" icon="flask">
    Test error handling with invalid inputs
  </Card>
</CardGroup>

